<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Number Match Solver</title>
<style>
  :root { --green: #4CAF50; --orange: #FF9800; --bg: #FAFAFA; }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    max-width: 560px; margin: 0 auto; padding: 20px; background: var(--bg);
    color: #333;
  }
  h1 { color: #333; border-bottom: 2px solid var(--green); padding-bottom: 8px; margin-bottom: 20px; }
  h2 { color: #555; margin: 32px 0 12px; }

  .input-section {
    background: #fff; border-radius: 8px; padding: 20px;
    box-shadow: 0 1px 3px rgba(0,0,0,.1); margin-bottom: 20px;
  }
  .input-section label { font-weight: 600; display: block; margin-bottom: 6px; }
  .input-section textarea {
    width: 100%; height: 120px; font-family: monospace; font-size: 16px;
    padding: 10px; border: 1px solid #ccc; border-radius: 6px; resize: vertical;
  }
  .input-section textarea:focus { outline: none; border-color: var(--green); }
  .btn {
    display: inline-block; padding: 10px 28px;
    background: var(--green); color: #fff; border: none; border-radius: 6px;
    font-size: 15px; font-weight: 600; cursor: pointer; transition: background .2s;
  }
  .btn:hover { background: #43A047; }
  .btn:disabled { background: #aaa; cursor: not-allowed; }
  .btn-secondary {
    background: #E3F2FD; color: #1976D2; border: 1px solid #90CAF9;
  }
  .btn-secondary:hover { background: #BBDEFB; }
  .btn-clear {
    background: #FFEBEE; color: #C62828; border: 1px solid #EF9A9A;
  }
  .btn-clear:hover { background: #FFCDD2; }
  .button-row {
    display: flex; gap: 12px; margin-top: 12px; flex-wrap: wrap;
  }
  .button-row .btn { margin-top: 0; flex: 1; min-width: 100px; }
  .hint { font-size: 12px; color: #999; margin-top: 6px; }
  .textarea-wrapper { position: relative; }
  .spinner-overlay {
    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(255, 255, 255, 0.9); display: none;
    align-items: center; justify-content: center; border-radius: 6px;
    z-index: 10;
  }
  .spinner-overlay.active { display: flex; }
  .spinner {
    width: 40px; height: 40px; border: 4px solid #f3f3f3;
    border-top: 4px solid var(--green); border-radius: 50%;
    animation: spin 1s linear infinite;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  .file-input-wrapper { display: none; }
  .file-input-wrapper input[type="file"] { display: none; }
  #image-preview { max-width: 25%; margin: 12px auto 0; border-radius: 6px; display: none; }

  #status {
    font-size: 14px; color: #555; padding: 8px 0; min-height: 24px;
    font-family: monospace; white-space: pre-wrap;
  }
  #results { margin-top: 12px; }

  .step {
    background: #fff; border-radius: 8px; padding: 16px; margin: 16px 0;
    box-shadow: 0 1px 3px rgba(0,0,0,.1); position: relative;
  }
  .step-title { font-weight: 700; margin-bottom: 4px; color: #444; }
  .step-nav {
    position: absolute; top: 16px; right: 16px; display: flex; gap: 8px;
  }
  .step-nav-btn {
    background: #F5F5F5; border: 1px solid #DDD; border-radius: 4px;
    padding: 4px 12px; font-size: 13px; font-weight: 600; cursor: pointer;
    color: #555; transition: background .2s;
  }
  .step-nav-btn:hover { background: #E0E0E0; }
  .step-nav-btn:disabled {
    background: #F5F5F5; color: #BBB; cursor: not-allowed; opacity: 0.5;
  }
  .move-list { font-size: 13px; color: #666; margin: 4px 0 12px; line-height: 1.7; }
  .move-item {
    display: inline-block; background: #F5F5F5; border-radius: 4px;
    padding: 1px 6px; margin: 2px; white-space: nowrap;
  }
  .extend-banner {
    background: #FFF3E0; border-left: 4px solid var(--orange);
    padding: 12px 16px; margin: 24px 0; border-radius: 4px;
    font-weight: 700; color: #E65100;
  }
  .final { background: #E8F5E9; }
  .row-removed { font-size: 12px; color: #E65100; font-style: italic; margin-top: 4px; }
  .summary {
    background: #E8F5E9; border-left: 4px solid var(--green);
    padding: 14px 18px; margin: 20px 0; border-radius: 4px;
    font-weight: 700; color: #2E7D32; font-size: 15px;
  }
</style>
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<script src="solver.js"></script>
<script src="image-processor.js"></script>
</head>
<body>
<h1>Number Match Solver</h1>

<div class="input-section">
  <label for="board-input">Enter board</label>
  <div class="textarea-wrapper">
    <textarea id="board-input" placeholder="123...456
23...4567" spellcheck="false">147179814
786565452
557892137
61656</textarea>
    <div class="spinner-overlay" id="spinner-overlay">
      <div class="spinner"></div>
    </div>
  </div>
  <div class="hint">Digits 1-9 for numbers, <code>.</code> for cleared cells. One row per line.</div>
  <div class="button-row">
    <button class="btn" id="solve-btn" onclick="startSolve()">Solve</button>
    <button class="btn btn-clear" id="clear-btn" onclick="clearBoard()">Clear</button>
    <button class="btn btn-secondary" id="screenshot-btn" onclick="triggerScreenshotUpload()">ğŸ“· Screenshot</button>
  </div>
  <div class="file-input-wrapper">
    <input type="file" id="screenshot-input" accept="image/*" onchange="handleScreenshotUpload(event)">
  </div>
  <img id="image-preview" alt="Screenshot preview">
</div>

<div id="status"></div>
<div id="results"></div>

<script>
"use strict";

// â”€â”€â”€ Clear board â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function clearBoard() {
  document.getElementById("board-input").value = "";
}

// â”€â”€â”€ Trigger screenshot upload â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function triggerScreenshotUpload() {
  document.getElementById("screenshot-input").click();
}

// â”€â”€â”€ Screenshot Processing (UI handler) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function handleScreenshotUpload(event) {
  const file = event.target.files[0];
  if (!file) return;

  const statusEl = document.getElementById("status");
  const previewEl = document.getElementById("image-preview");
  const textareaEl = document.getElementById("board-input");
  const spinnerEl = document.getElementById("spinner-overlay");

  // Show spinner
  spinnerEl.classList.add("active");
  statusEl.textContent = "Processing screenshot...";

  // Show preview
  const reader = new FileReader();
  reader.onload = async (e) => {
    previewEl.src = e.target.result;
    previewEl.style.display = "block";
    try {
      const boardStr = await processScreenshot(e.target.result, (status) => {
        statusEl.textContent = status;
      });
      
      // Update textarea first
      textareaEl.value = boardStr;
      
      // Force a reflow to ensure the textarea update is painted
      void textareaEl.offsetHeight;
      
      // Remove spinner and update status
      spinnerEl.classList.remove("active");
      statusEl.textContent = "Board extracted! Starting solve...";
      
      // Allow browser to paint the UI updates before starting solve
      requestAnimationFrame(() => {
        setTimeout(() => {
          startSolve();
        }, 150);
      });
    } catch (err) {
      spinnerEl.classList.remove("active");
      statusEl.textContent = "Error: " + err.message;
      console.error(err);
    }
  };
  reader.readAsDataURL(file);
}

// â”€â”€â”€ UI Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CELL_SIZE = 50;
const LINE_COLORS = [
  "#E53935","#1E88E5","#43A047","#FB8C00","#8E24AA",
  "#00ACC1","#D81B60","#6D4C41","#546E7A","#FFB300",
  "#7CB342","#039BE5","#C0CA33","#F4511E","#5E35B1",
];

function boardToSvg(board, moves, highlightIdx, removedRows) {
  if (!board || !board.length) {
    return '<div style="color:#4CAF50;font-weight:bold;padding:8px">Board cleared!</div>';
  }
  moves = moves || [];
  highlightIdx = highlightIdx ?? -1;
  // removedRows can be a single number, an array, or undefined
  const removedRowsSet = new Set();
  if (removedRows !== undefined && removedRows !== null) {
    if (Array.isArray(removedRows)) {
      removedRows.forEach(r => { if (r >= 0) removedRowsSet.add(r); });
    } else if (removedRows >= 0) {
      removedRowsSet.add(removedRows);
    }
  }

  const nRows = board.length / ROW_SIZE;
  const w = ROW_SIZE * CELL_SIZE, h = nRows * CELL_SIZE;
  // Map cell index to move index (k) so we can use the same color as the line
  const cellToMoveIdx = new Map();
  for (let k = 0; k < moves.length; k++) {
    const [mi, mj] = moves[k];
    cellToMoveIdx.set(mi, k);
    cellToMoveIdx.set(mj, k);
  }

  let svg = `<svg viewBox="0 0 ${w} ${h}" xmlns="http://www.w3.org/2000/svg" ` +
            `style="display:block;max-width:100%;height:auto;margin:0 auto">`;

  for (let idx = 0; idx < board.length; idx++) {
    const [r, c] = getRowCol(idx);
    const x = c * CELL_SIZE, y = r * CELL_SIZE;
    const val = board[idx];
    const isInRemovedRow = removedRowsSet.has(r);
    const isHighlighted = cellToMoveIdx.has(idx);
    let fill, stroke, fillOpacity = 1;
    
    if (isHighlighted) {
      const moveIdx = cellToMoveIdx.get(idx);
      const lineColor = LINE_COLORS[moveIdx % LINE_COLORS.length];
      fill = lineColor;
      fillOpacity = 0.3; // Lower opacity for cell background
      stroke = lineColor; // Stroke uses same color but will be at full opacity
    } else if (val > 0) {
      fill = "#F5F5F5";
      stroke = "#DDD";
    } else if (isInRemovedRow) {
      // Cells in removed row that aren't highlighted - make them grayer
      fill = "#E0E0E0";
      stroke = "#C0C0C0";
    } else if (val === 0) {
      fill = "#FAFAFA";
      stroke = "#EEE";
    } else {
      fill = "#FFF";
      stroke = "#F5F5F5";
    }

    svg += `<rect x="${x+2}" y="${y+2}" width="${CELL_SIZE-4}" height="${CELL_SIZE-4}" ` +
           `fill="${fill}" fill-opacity="${fillOpacity}" stroke="${stroke}" rx="4"/>`;

    if (val > 0) {
      const fw = isHighlighted ? "bold" : "normal";
      // Make text slightly grayer if in removed row and not highlighted
      const textColor = (isInRemovedRow && !isHighlighted) ? "#666" : "#333";
      svg += `<text x="${x+CELL_SIZE/2}" y="${y+CELL_SIZE/2+11}" ` +
             `text-anchor="middle" font-size="30" font-family="monospace" ` +
             `font-weight="${fw}" fill="${textColor}">${val}</text>`;
    } else if (val === 0) {
      svg += `<text x="${x+CELL_SIZE/2}" y="${y+CELL_SIZE/2+5}" ` +
             `text-anchor="middle" font-size="16" fill="#CCC">\u00b7</text>`;
    }
  }

  for (let k = 0; k < moves.length; k++) {
    const [mi, mj] = moves[k];
    const [ri, ci] = getRowCol(mi), [rj, cj] = getRowCol(mj);
    const x1 = ci*CELL_SIZE + CELL_SIZE/2, y1 = ri*CELL_SIZE + CELL_SIZE/2;
    const x2 = cj*CELL_SIZE + CELL_SIZE/2, y2 = rj*CELL_SIZE + CELL_SIZE/2;
    const color = LINE_COLORS[k % LINE_COLORS.length];
    const sw = k === highlightIdx ? 5 : 3;
    const op = k === highlightIdx ? 0.9 : 0.7;
    svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" ` +
           `stroke="${color}" stroke-width="${sw}" stroke-linecap="round" opacity="${op}"/>`;
  }
  svg += "</svg>";
  return svg;
}

// â”€â”€â”€ Helper function to calculate removed rows â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calculateRemovedRows(boardBefore, moves) {
  /**
   * Determines which rows will be removed after applying all moves.
   * Returns an array of row numbers (0-indexed) that will be removed.
   */
  const rowsBefore = boardBefore.length / ROW_SIZE;
  const removedRows = [];
  
  // Apply all moves to a copy (clearing cells but not removing rows)
  const tempBoard = boardBefore.slice();
  for (const [mi, mj] of moves) {
    tempBoard[mi] = 0;
    tempBoard[mj] = 0;
  }
  
  // Find all rows that are now completely empty (all zeros or -1s)
  for (let r = 0; r < rowsBefore; r++) {
    const start = r * ROW_SIZE;
    const row = tempBoard.slice(start, start + ROW_SIZE);
    if (!row.some(v => v > 0)) {
      // This row is now empty, so it will be removed
      removedRows.push(r);
    }
  }
  return removedRows;
}

// â”€â”€â”€ HTML generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function renderSolution(initialBoard, phases) {
  let html = "";
  let moveCounter = 0, stepCounter = 0;
  const allStepIds = [];

  for (let pi = 0; pi < phases.length; pi++) {
    const { label, startBoard, moves } = phases[pi];
    html += `<h2>${label}</h2>`;

    if (pi > 0) {
      html += `<div class="extend-banner">\u27f3 Board extended &mdash; remaining numbers duplicated</div>`;
      const extendStepId = `step-extend-${pi}`;
      allStepIds.push(extendStepId);
      html += `<div class="step" id="${extendStepId}">`;
      html += `<div class="step-nav">`;
      html += `<button class="step-nav-btn" onclick="navigateStep('${extendStepId}', -1)">â† Prev</button>`;
      html += `<button class="step-nav-btn" onclick="navigateStep('${extendStepId}', 1)">Next â†’</button>`;
      html += `</div>`;
      html += `<div class="step-title">Extended board</div>${boardToSvg(startBoard)}</div>`;
    }

    const groups = groupMovesForDisplay(startBoard, moves);

    for (const { board: gBoard, moves: gMoves, rowRemovalIdx } of groups) {
      stepCounter++;
      const stepId = `step-${stepCounter}`;
      allStepIds.push(stepId);
      const rowsRemoved = rowRemovalIdx >= 0;
      
      // Calculate which rows are being removed
      let removedRows = [];
      if (rowsRemoved) {
        removedRows = calculateRemovedRows(gBoard, gMoves);
      }
      
      const descs = gMoves.map(([mi, mj]) => {
        moveCounter++;
        return `<span class="move-item">${gBoard[mi]} \u2194 ${gBoard[mj]}</span>`;
      });
      const n = gMoves.length;
      const rowText = rowsRemoved 
        ? (removedRows.length > 1 ? ` (removes ${removedRows.length} rows)` : " (removes row)")
        : "";
      html += `<div class="step" id="${stepId}">`;
      html += `<div class="step-nav">`;
      html += `<button class="step-nav-btn" onclick="navigateStep('${stepId}', -1)">â† Prev</button>`;
      html += `<button class="step-nav-btn" onclick="navigateStep('${stepId}', 1)">Next â†’</button>`;
      html += `</div>`;
      html += `<div class="step-title">Step ${stepCounter}: ${n} move${n!==1?"s":""}${rowText}</div>`;
      html += `<div class="move-list">${descs.join(" ")}</div>`;
      html += boardToSvg(gBoard, gMoves, rowRemovalIdx, removedRows);

      if (rowsRemoved) {
        let temp = gBoard;
        for (const mv of gMoves) temp = applyMove(temp, mv[0], mv[1]);
        const nRemoved = (gBoard.length - temp.length) / ROW_SIZE;
        html += `<div class="row-removed">\u2191 ${nRemoved} empty row${nRemoved!==1?"s":""} ` +
                `removed after this step</div>`;
      }
      html += `</div>`;
    }

    // Final board after phase
    let finalBoard = startBoard;
    for (const mv of moves) finalBoard = applyMove(finalBoard, mv[0], mv[1]);
    const rem = remainingCount(finalBoard);
    const finalStepId = `step-final-${pi}`;
    allStepIds.push(finalStepId);
    html += `<div class="step final" id="${finalStepId}">`;
    html += `<div class="step-nav">`;
    html += `<button class="step-nav-btn" onclick="navigateStep('${finalStepId}', -1)">â† Prev</button>`;
    html += `<button class="step-nav-btn" onclick="navigateStep('${finalStepId}', 1)">Next â†’</button>`;
    html += `</div>`;
    html += `<div class="step-title">After ${label}: ` +
            `${rem} cell${rem!==1?"s":""} remaining</div>${boardToSvg(finalBoard)}</div>`;
  }
  
  // Store step IDs globally for navigation
  window.allStepIds = allStepIds;
  
  // Update button states after rendering
  setTimeout(() => {
    updateStepNavButtons();
  }, 0);
  
  return html;
}

// â”€â”€â”€ Step navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function navigateStep(currentStepId, direction) {
  if (!window.allStepIds || window.allStepIds.length === 0) return;
  
  const currentIdx = window.allStepIds.indexOf(currentStepId);
  if (currentIdx === -1) return;
  
  const newIdx = currentIdx + direction;
  if (newIdx < 0 || newIdx >= window.allStepIds.length) return;
  
  const targetStepId = window.allStepIds[newIdx];
  const targetEl = document.getElementById(targetStepId);
  if (targetEl) {
    targetEl.scrollIntoView({ behavior: 'auto', block: 'start' });
  }
}

function updateStepNavButtons() {
  if (!window.allStepIds || window.allStepIds.length === 0) return;
  
  window.allStepIds.forEach((stepId, idx) => {
    const stepEl = document.getElementById(stepId);
    if (!stepEl) return;
    
    const navBtns = stepEl.querySelectorAll('.step-nav-btn');
    if (navBtns.length >= 2) {
      const prevBtn = navBtns[0];
      const nextBtn = navBtns[1];
      
      prevBtn.disabled = idx === 0;
      nextBtn.disabled = idx === window.allStepIds.length - 1;
    }
  });
}

// â”€â”€â”€ Main solve logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function startSolve() {
  const btn = document.getElementById("solve-btn");
  const statusEl = document.getElementById("status");
  const resultsEl = document.getElementById("results");
  btn.disabled = true;
  resultsEl.innerHTML = "";
  statusEl.textContent = "Solving phase 1...";

  setTimeout(() => {
    try {
      runFullSolve(statusEl, resultsEl);
      btn.disabled = false;
    }
    catch (e) {
      statusEl.textContent = "Error: " + e.message;
      console.error(e);
      btn.disabled = false;
    }
  }, 50);
}

function runFullSolve(statusEl, resultsEl) {
  const input = document.getElementById("board-input").value;
  const board = parseBoard(input);
  if (!board.length || remainingCount(board) === 0) {
    statusEl.textContent = "Please enter a valid board.";
    return;
  }

  const t0 = performance.now();

  // Use multi-phase solver
  const result = solveMultiPhase(board, 5, 100, (msg) => {
    statusEl.textContent = msg;
    // Also log to console (non-verbose output)
    console.log(msg);
  });

  const elapsed = ((performance.now() - t0) / 1000).toFixed(1);

  if (!result.bestSolution) {
    statusEl.textContent = "No solution found!";
    return;
  }

  const { bestSolution } = result;
  statusEl.textContent = `Done in ${elapsed}s. ` +
    `Best: ${bestSolution.remaining} remaining, ${bestSolution.totalMoves} total moves ` +
    `(${result.allPhases.length} phase${result.allPhases.length !== 1 ? "s" : ""}).`;

  // Build phases for display from bestSolution
  const phases = bestSolution.phaseSeqs.map((seq, idx) => ({
    label: `Phase ${idx + 1}`,
    startBoard: bestSolution.phaseBoards[idx],
    moves: seq,
  }));

  let html = `<div class="summary">Best: ${bestSolution.remaining} remaining, ` +
             `${bestSolution.totalMoves} moves across ${bestSolution.phaseSeqs.length} phase${bestSolution.phaseSeqs.length !== 1 ? "s" : ""}</div>`;
  html += renderSolution(board, phases);
  resultsEl.innerHTML = html;
  
  // Scroll to the first step after rendering (smooth scroll)
  setTimeout(() => {
    if (window.allStepIds && window.allStepIds.length > 0) {
      const firstStepId = window.allStepIds[0];
      const firstStepEl = document.getElementById(firstStepId);
      if (firstStepEl) {
        firstStepEl.scrollIntoView({ behavior: 'smooth', block: 'start' });
      }
    }
  }, 0);
}
</script>
</body>
</html>
